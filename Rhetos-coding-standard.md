Table of contents:

1. [Business application development](#business-application-development)
2. [Developing new DSL concepts](#developing-new-dsl-concepts)

## Business application development

### Naming convention

* Rhetos DSL scripts are not case-sensitive, but the Rhetos will generate C# code that is case sensitive,
  therefore it is important to use letter case consistently.
* Use PascalCase notation for all DSL objects.
* Entity name must describe a *single record* of the entity.
  This means that the singular from should be used, unless a single record represents multiple instances.
  This also applies to other data structures.
* Do not use *underscore* in names, they are reserved for objects generated by the system.
* Avoid names like "Type" and "Class".
  Such name does not describe the criteria used for classification.
  An extreme example of this problem is an application that has multiple classification with incomprehensible names: ArticleType, ArticleClass and ArticleCategory.

### Formatting

* Use [Allman indentation style](https://en.wikipedia.org/wiki/Indent_style#Allman_style).
* Simple embedded concepts can be written in a single line, for example `ShortString Name { Required; Unique; }`, instead of writing the curly brackets separately in each line.
* Use 4 spaces for indentation instead of tabs.
* Use one empty line to separate logical groups of code.
  Avoid more than one empty line.
* Avoid spurious free spaces.
* Larger SQL code snippets should be extracted to a separate .sql file in the SQL subfolder.
  The file can be referenced from the .rhe script, for example: `SqlQueryable DocumentInfo <SQL\DocumentInfo.sql> { ... `.

### Organizing DSL scripts

* DSL scripts (.rhe) must be placed inside the DslScripts subfolder inside the Rhetos package's folder.
* Use "UTF-8 with BOM" encoding for the .rhe scripts.
* The application should be separated to multiple module if it is possible to deploy a different combination of modules to different clients.
  Each module should be developed as a separate Rhetos package.
* For larger modules the DSL scripts should be distributed by topic to subfolders inside the DslScripts folder.
* Each main entity should have its own DSL script.
  The script may contain the associated detail entities, filters, validation and other functionality closely related to the entity.
  Name of this DSL script should be same as entity.

### Error messages

It is easy to overlook what the error message will look like to a user that doesn't understand the full context of the feature you are working on.

Error message should explain:

1. Type of the error.
    - When confronted with an error message, a user might assume that the software simply "does not work".
      The message should communicate clearly the type of an error:
    - If **a bug** occurred the message should start with `Internal system error ...`.
      Note that `Rhetos.FrameworkException` assumes internal server error, so this text should be omitted from the exception message,
      but should be presented to the user at GUI.
    - If the user entered **invalid data** (a data that breaks some business rule, such as InvalidData) message should start with `It is not allowed to enter ...`. For example, `It is not allowed to enter a duplicate record.`.
    - If the user's **access is restricted**, the message should start with `Insufficient permissions` or `You are not authorized to ...`.
2. The user's data that caused an error. Sometime the user's action causes change in multiple entities or properties.
   The provided data should help pinpoint the cause of the problem.
3. What should the user do next. For example, `Please enter the <PropertyName>.`,
   `Please check <SomeOtherEntity> for allowed entries.`, `Please contact your system administrator.`,
   `Please try again in a minute or contact your system administrator.`.

Other:

1. Use sentences in error messages (end them with a dot).
2. Avoid exclamation mark. The user should not panic.

### Antipatterns

* Avoid using lazy-loading when reading referenced data.
    - Slow code example:
      All columns are read from the movie table, event those that are not needed.
      An additional query is executed for each lazy evaluation of a reference to the movie's director.

        ```
        var movies = repository.Demo.Movies.Query().ToList();

        foreach (var movie in movies)
            if (!movie.Name.Contains(movie.Director.Name))
                throw UserException("Movie name must contain the director's name.");
        ```

    - Better code:
      Only movie names and director names are read from the database.
      Only one SQL query is executed.

        ```
        var movies = repository.Demo.Movies.Query()
            .Select(movie => new { movie.Name, DirectorName = movie.Director.Name }).ToList();

        foreach (var movie in movies)
            if (!movie.Name.Contains(movie.DirectorName))
               throw UserException("Movie name must contain the director's name.");
        ```

* Try to use a single entity for each business event, so that most user's business process operations can be mapped to a single INSERT operation to the entity that represents the corresponding business process event.
* Avoid using `Action` concept to save master and detail entity in a same transaction.
  Redesign the user interface to allow entering master and detail separately without loss of consistency.
* Avoid using `Action` or `SaveMethod` concept to update related computed (redundant) data when saving an entity.
  Use the following Rhetos concepts to keep the computed data up-to-date: `Persisted`, `ComputedFrom`, `KeepSynchronized` and `ChangesOn`.
  Use simple CRUD operations for saving the data.
* Avoid using `Action` or `SaveMethod` concept for data validation.
  Use the following Rhetos concepts: `InvalidItem`, `Lock`, `LockExcept`, `DenyUserEdit`, or implement a new high-level concept where needed.

## Developing new DSL concepts

### Concept naming convention

* PascalCase notation.
* Avoid decorative prefixes "Is" and "Has" in the concept's keyword.
  These prefixes are implied for each feature, for example:
  `Property ... { IsRequired` (the name should be `Required`),
  `Entity ... { HasShortStringProperty` (the name should be `ShortStringProperty`).
* If a concept inherits or replaces another one, its name should end with the other concept's name.
  Example: `ShortStringProperty` inherits `Property`.
  Note that the concept's keyword may be simplified from the internal full name (`ShortString`, for example).
* If a concept extends behavior of another concept so that it can be embedded in the another one,
  the concept's name should start with the other concept's name.
  Example: `PropertyRequired`, not `RequiredProperty`.
  Note that the concept's keyword may be simplified from the internal full name (`Required`, for example).

### Principles and guidelines

* The design goal is to allow adding new functionality without a quadratic (or exponential) increase of the software's complexity.
  This is achieved by minimizing the dependencies between the features as much as possible.
* "Feature-outside design".
    - A single concept should not include all functionality that is applicable to the concept.
      It should implement only the basic functionality, and use other concepts to extend the basic functionality.
      More precisely, we should avoid scenarios when a single concept supports multiple options that can be turned on or off.
      There should be multiple concepts for each feature, and each concept's functionality should not be configurable.
      The configurability should be achieved by combining the concepts in different ways.
    - For example, the Entity concept creates a database table and a C# class with the ID property.
      That concept's implementation does not include any other functionality that an entity could have.
      Different property types or business logic are all implemented in the separate concepts that extend the base entity's behavior.
    - Implementation of the concepts should include the base behavior and the extension points (tags in the generated source) for other concepts to use.
* Implementation of each concept should effect only the concepts that this concept is referencing.
  This should suppress the quadratic increase in complexity caused by possible dependencies between features.
  The exception are macros that can be used to create other concepts dependent on any feature in the application's model.
  Implementation of those generated concepts must still follow the rule of using only the concepts that those reference.
    - When developing DatabaseGenerator plugins, breaking this rule may cause inability to deploy the application because of strict dependencies between database objects.
      For other plugin types it can hinder the extensibility.
* New concept may extend the behavior of referenced concepts, but it should never override or modify their existing behavior.
  Sometimes this rule requires more effort to implement certain features, but it will allow easier long-term maintenance of the software.
